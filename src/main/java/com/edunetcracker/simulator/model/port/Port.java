package com.edunetcracker.simulator.model.port;

import com.edunetcracker.simulator.model.DBObject;
import com.edunetcracker.simulator.model.Link;
import com.edunetcracker.simulator.model.dataUnit.DataUnit;
import com.edunetcracker.simulator.model.dataUnit.IDataUnit;
import com.edunetcracker.simulator.model.element.NetworkElement;
import com.edunetcracker.simulator.service.status.SequenceStatus;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.Setter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;

import javax.persistence.*;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;

@Getter
@Setter
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Port implements DBObject<Port> {

    @Transient
    private static Logger logger = LoggerFactory.getLogger(Port.class);

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @JsonProperty
    private long id;

    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @JsonProperty
    @Column(name = "mac", unique = true)
    private long mac;

    //Order of the ports in the NE
    @Column(name = "port_order")
    @JsonProperty
    private int order;


    public void setMac (long mac) {
        this.mac = mac;
    }

    @Transient
    @JsonProperty
    private boolean isActive;

    @Transient
    private Link.Connection connection;


    public Port (){
//ToDo
//        id = Long.valueOf(UUID.randomUUID().toString());
//        mac = 0;
//        order = 0;
    }

    public Port(long id, long mac, int order){
        this.id = id;
        this.mac = mac;
        this.order = order;
    }

    @Override
    public SequenceStatus copyRefs (Port another) {
        connection = another.connection;
        return SequenceStatus.OK;
    }

    @Override
    public SequenceStatus copyAutogeneratedValues (Port another) {
        id = another.id;
        mac = another.mac;
        return SequenceStatus.OK;
    }

    public abstract NetworkElement checkForOwner();


    /**
     * Transfers the dataUnit to the physical layer
     * (a.k.a. puts the dataUnit to port's connection's output queue).
     * @param dataUnit
     * @return null, if the dataUnit was transferred successfully,
     *         or the modified dataUnit to be reconsidered otherwise.
     */
    public DataUnit push (DataUnit dataUnit) {
        if (null == dataUnit) {
            throw new NullPointerException();
        }
        DataUnit retDataUnit = null;
        if (!connection.getOut().offer(dataUnit)) {
            retDataUnit = rejectedDueToOverflow(dataUnit);
        }
        logger.info("Pushed {} through port {}.", dataUnit.getType(), id);
        return retDataUnit;
    }

    protected abstract DataUnit rejectedDueToOverflow (DataUnit dataUnit);

    public ConcurrentLinkedQueue<DataUnit> getIn () {
        if (null == connection) {
            return null;
        }
        return connection.getIn();
    }

    public boolean hasInput () {
        if (connection == null) {
            return false;
        }
        return !connection.getIn().isEmpty();
    }
}
