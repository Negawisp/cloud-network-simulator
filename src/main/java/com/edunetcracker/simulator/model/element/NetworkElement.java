
package com.edunetcracker.simulator.model.element;

import com.edunetcracker.simulator.model.DBObject;
import com.edunetcracker.simulator.model.context.NEContext;
import com.edunetcracker.simulator.model.Scene;
import com.edunetcracker.simulator.model.dataUnit.DataUnit;
import com.edunetcracker.simulator.service.context.ContextService;
import com.edunetcracker.simulator.service.status.SequenceStatus;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.Setter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import javax.persistence.*;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;

@Setter
@Getter
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class NetworkElement extends Thread implements DBObject<NetworkElement> {

    @Autowired
    static ContextService contextService;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @JsonProperty
    private long idNE;

    @Column
    @JsonProperty
    private long x;

    @Column
    @JsonProperty
    private long y;

    @Column
    @JsonProperty
    private String physConfigType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "scene_id", referencedColumnName = "id")
    private Scene scene;

    @Transient
    protected List<NEContext> contexts;

    @Transient
    private boolean working = true;


    @Transient
    protected final static int inputProcessingTime = 30;
    @Transient
    protected final static int commandProcessingTime = 30;
    @Transient
    protected final static int contextProcessingTime = 60;

    @Transient
    protected final static int inputProcessingRate = 100;

    //tasks from user
    @Transient
    private ConcurrentLinkedQueue   userInput;
    @Transient
    private ConcurrentLinkedQueue   userOutput;


    public NetworkElement() {
        contexts = new LinkedList<>();
    }

    protected NetworkElement(int id) {
        this.idNE = id;
    }

    @Override
    public SequenceStatus copyRefs(NetworkElement another) {
        scene = another.scene;
        userInput = another.userInput;
        userOutput = another.userOutput;
        return SequenceStatus.OK;
    }

    @Override
    public SequenceStatus copyAutogeneratedValues (NetworkElement another) {
        idNE = another.idNE;
        return SequenceStatus.OK;
    }

    @Override
    public void run() {

        Long stamp = 0L;

        while (working) {
             stamp = System.currentTimeMillis();
             
             processCommands();
             processInputTraffic();
             processContexts();

            try {
                //so that time would split into equal parts
                Thread.sleep(100 + stamp - System.currentTimeMillis());
            } catch (InterruptedException ie) {
                Logger logger = LoggerFactory.getLogger(NetworkElement.class);
                logger.error(ie.getMessage());
            }
        }

    }

    protected abstract void processContexts();

    protected abstract void processInputTraffic();

    protected abstract void processCommands();

    @Override
    public String toString() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibilityChecker(mapper.getDeserializationConfig().getDefaultVisibilityChecker()
                .withCreatorVisibility(JsonAutoDetect.Visibility.NONE)
                .withFieldVisibility(JsonAutoDetect.Visibility.NONE)
                .withGetterVisibility(JsonAutoDetect.Visibility.NONE)
                .withIsGetterVisibility(JsonAutoDetect.Visibility.NONE)
                .withSetterVisibility(JsonAutoDetect.Visibility.NONE));
        String result = null;
        try {
            result = mapper.writeValueAsString(this);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return result;
    }

}


